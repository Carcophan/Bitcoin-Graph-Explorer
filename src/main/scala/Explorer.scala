import java.io.File
import actions._
import util._
import core._

/**
 * Created with IntelliJ IDEA.
 * User: yzark
 * Date: 11/19/1
 * Time: 12:36 PM
 * To change this template use File | Settings | File Templates.
 */
object Explorer extends App{
  args.toList match{
    // we could write a version of populate that just
    // parse the blocks - tx - outputs - inputs
    case "test-addresses"::rest =>
      object TestBlockReader extends BitcoinDRawFileBlockSource with TestBlockReader //needs to be in this order for linearization
      TestBlockReader
    case "analyze-script"::rest             =>
      (new ScriptReader)
    case "test-script"::rest             =>
      (new ScriptTester)
    case "reader"::rest           =>
      object InitializeBlockReader extends BitcoinDRawFileBlockSource with FastBlockReader //needs to be in this order for linearization
      InitializeBlockReader
    case "populate"::rest             =>
      object InitializeBlockReader extends BitcoinDRawFileBlockSource with FastBlockReader //needs to be in this order for linearization
      InitializeBlockReader
      CreateIndexes
      CreateAddressIndexes
    case "closure"::rest             =>
      FastAddressClosure
      CreateAddressIndexes

    case "stats"::rest =>
      SlowStatistics
    case "resume"::rest               =>
//      object ResumeBlockReader extends HttpBlockSource with SlowBlockReader //needs to be in this order for linearization
  //    ResumeBlockReader
      // new SlowAddressClosure(ResumeBlockReader.savedMovements)
      //new SlowAddressBalance(ResumeBlockReader.savedMovements)
      // apply required to call the methods more than one time,
      // which is required for the loop run bge
    //  SlowStatistics.apply
     // SlowClosureGini.apply
     // SlowAddressGini.apply
     // SlowRichestAddresses.apply
     // SlowRichestClosures.apply
    case "test_utxo"::rest =>
      val test = readUTXOs
      println("wir sind geil")
      System.gc
      Thread.sleep(60000)
      println("Wir waren geil")

    case "richest"::rest =>
      SlowRichestClosures.apply
      SlowRichestAddresses.apply
    case "index_2"::rest =>
      CreateAddressIndexes
    case "index_1"::rest =>
      CreateIndexes
    case "gini"::rest =>
      SlowAddressGini.apply
      SlowClosureGini.apply
    case "bge"::rest =>
      import sys.process._

      while (new java.io.File("/nix/bge/lock").exists)
      {
        val cmd = Seq("cat", "/nix/.bitcoin/blocklist.txt") #| Seq( "wc", "-l")
        val cmd2 = Seq("mysql", "movements", "--host=172.17.0.61", "--port" ,"3306", "-u", "root", "-ptrivial", "-se", "select max(block_height) from blocks") #| Seq("cut", "-f1")
        val from = Integer.parseInt(cmd2.lines.head,10)
        val to = Integer.parseInt(cmd.lines.head, 10) - 1

        if (to > from+2)
        {
          println("Reading blocks from " +from + " to " +to)
          object ResumeBlockReader extends BitcoinDRawFileBlockSource with SlowBlockReader //needs to be in this order for linearization
          ResumeBlockReader
          //new SlowAddressClosure(ResumeBlockReader.savedMovements)
          //new SlowAddressBalance(ResumeBlockReader.savedMovements)
          SlowStatistics.apply
          SlowClosureGini.apply
          SlowAddressGini.apply
          SlowRichestAddresses.apply
          SlowRichestClosures.apply
        }
        else
        {
          println("waiting for new blocks")
          Thread sleep 60000
        }
      }
      println("process stopped")



    case _=> println("""
      Available commands:
       reader: call fast block reader
       closure: call fast address closure
       balance: call fast address balance
       bge:  call resume in a loop, whenever are new blocks
       gini: calculate gini coefficients
       stats: calculate the stats
       richest: calculate richest lists
       index_1: create indexes for movements
       index_2: create indexes for addresses
       populate: create the database movements with movements and closures.
       resume: update the database generated by populate with new incomming data.
       test-addresses: read every block and try to generate address for every single output.
       test-script: read the blockchain/scripts.log file and perform a custom test over each line.
       analyze-script: read and print an inform from blockchain/scripts.log.
    """)
  }
}
