import java.io.File
import actions._
import util._
import core._

/**
 * Created with IntelliJ IDEA.
 * User: yzark
 * Date: 11/19/1
 * Time: 12:36 PM
 * To change this template use File | Settings | File Templates.
 */
object Explorer extends App {
  args.toList match{

    case "populate"::rest             =>
      initializeReaderTables
      PopulateBlockReader
      createIndexes
      closure(PopulateBlockReader.processedBlocks)
      initializeStatsTables
      populateStats

    case "resume"::rest =>
      import sys.process._

      val lch = lastCompletedHeight
      val bc = blockCount

      while (new java.io.File("/root/Bitcoin-Graph-Explorer/blockchain/lock").exists)
      {
        for (i <- (lch +1 until bc).reverse){
          println("rolling back block " + i + " at " + java.util.Calendar.getInstance().getTime())
          rollBack
        }
        
        if (lch != bc-1)
          populateStats

        "/root/Bitcoin-Graph-Explorer/scripts/getblocklist.sh".! // TODO: replace this script with a scala function entirely!
        val cmd = Seq("cat", "/root/.bitcoin/blocklist.txt") #| Seq( "wc", "-l")
        val from = blockCount
        val to = Integer.parseInt(cmd.lines.head, 10)
        
        if (to > from)
        {
          println("Reading blocks from " + from + " until " + to)
          resume
        }
        else
        {
          println("waiting for new blocks")
          Thread sleep 60000
        }
      }
      println("process stopped")

    case "info"::rest =>
      getInfo

    case "copyUTXOs"::rest =>
      copyUTXOs

    case _=> println("""
      Available commands:

       populate: create the database movements with movements and closures.
       resume: update the database generated by populate with new incoming data.

    """)
  }

  def closure(blockList:Vector[Int]) = {
    initializeClosureTables
    new PopulateClosure(blockList)
    createAddressIndexes

  }

  def getInfo = {
    val (count, amount) = sumUTXOs
    println("Sum of the utxos saved in the lmdb: "+ amount)
    println("Total utxos in the lmdb: " + count)
    val (countDB, amountDB) = countUTXOs
    println("Sum of the utxos in the sql db " +amountDB)
    println("Total utxos in the sql db " + countDB)
  }

  def sumUTXOs = {
    lazy val table = LmdbMap.open("utxos")
    lazy val outputMap: UTXOs = new UTXOs (table)
    
    // (txhash,index) -> (address,value,blockIn)
    val values = for ( (_,(_,value,_)) <- outputMap.view) yield value //makes it a lazy collection
    val tuple = values.grouped(100000).foldLeft((0,0L)){
      case ((count,sum),group) =>
        println(count + " elements read at " + java.util.Calendar.getInstance().getTime())
        val seq = group.toSeq
        (count+seq.size,sum+seq.sum)
    }
    table.close
    tuple
  }

  
  def resume = {
    val read = new ResumeBlockReader
    new ResumeClosure(read.processedBlocks)
    println("DEBUG: making new stats")
    resumeStats(read.changedAddresses)
  }

  def resumeStats(changedAddresses: collection.mutable.Map[Hash,Long]) = {
    if (changedAddresses.size < 15000 )
      updateBalanceTables(changedAddresses)
    else
      createBalanceTables
    insertRichestAddresses
    insertRichestClosures
    insertStatistics
  }

  def populateStats = {
    createBalanceTables
    insertRichestAddresses
    insertRichestClosures
    insertStatistics
  }
}
