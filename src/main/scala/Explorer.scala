import java.io.File
import actions._
import util._
import core._

/**
 * Created with IntelliJ IDEA.
 * User: yzark
 * Date: 11/19/1
 * Time: 12:36 PM
 * To change this template use File | Settings | File Templates.
 */
object Explorer extends App{
  args.toList match{
    // we could write a version of populate that just
    // parse the blocks - tx - outputs - inputs
    case "test-addresses"::rest =>
      object TestBlockReader extends BitcoinDRawFileBlockSource with TestBlockReader //needs to be in this order for linearization
      TestBlockReader
    case "analyze-script"::rest             =>
      (new ScriptReader)
    case "test-script"::rest             =>
      (new ScriptTester)
    case "reader"::rest           =>
      object InitializeBlockReader extends BitcoinDRawFileBlockSource with FastBlockReader //needs to be in this order for linearization
      InitializeBlockReader
    case "populate"::rest             =>

      initializeReaderTables
      object InitializeBlockReader extends BitcoinDRawFileBlockSource with PopulateBlockReader //needs to be in this order for linearization
      InitializeBlockReader
      CreateIndexes
      initializeClosureTables
      new FastAddressClosure(LmdbMap.create("closures"), InitializeBlockReader.processedBlocks)
      CreateAddressIndexes

    case "closure"::rest             =>

      initializeClosureTables
      new FastAddressClosure(LmdbMap.create("closures"), (0 until 100000).toVector)
      CreateAddressIndexes

    case "stats"::rest =>

      SlowStatistics

    case "resume"::rest               =>
      object ResumeBlockReader extends PeerSource with ResumeBlockReader  //needs to be in this order for linearization
      ResumeBlockReader
      new ResumeClosure(LmdbMap.open("closures"), ResumeBlockReader.processedBlocks)
    // new SlowAddressClosure(ResumeBlockReader.savedMovements)
      //new SlowAddressBalance(ResumeBlockReader.savedMovements)
      // apply required to call the methods more than one time,
      // which is required for the loop run bge
    //  SlowStatistics.apply
     // SlowClosureGini.apply
     // SlowAddressGini.apply
     // SlowRichestAddresses.apply
     // SlowRichestClosures.apply
    case "test_utxo"::rest =>
      val test = readUTXOs
      println("wir sind geil")
      System.gc
      Thread.sleep(60000)
      println("Wir waren geil")

    case "richest"::rest =>
      SlowRichestClosures.apply
      SlowRichestAddresses.apply
    case "index_2"::rest =>
      CreateAddressIndexes
    case "index_1"::rest =>
      CreateIndexes
    case "gini"::rest =>
      SlowAddressGini.apply
      SlowClosureGini.apply
    case "bge"::rest =>
      import sys.process._

      while (new java.io.File("/root/Bitcoin-Graph-Explorer/blockchain/lock").exists)
      {
        val cmd = Seq("cat", "/root/.bitcoin/blocklist.txt") #| Seq( "wc", "-l")
        val from = blockCount
        val to = Integer.parseInt(cmd.lines.head, 10) - 1

        if (to > from+2)
        {
          println("Reading blocks from " +from + " to " +to)
          object ResumeBlockReader extends PeerSource with ResumeBlockReader  //needs to be in this order for linearization
          ResumeBlockReader
          new ResumeClosure(LmdbMap.open("closures"), ResumeBlockReader.processedBlocks)
        }
        else
        {
          println("waiting for new blocks")
          Thread sleep 60000
        }
      }
      println("process stopped")


    case _=> println("""
      Available commands:
       reader: call fast block reader
       closure: call fast address closure
       balance: call fast address balance
       bge:  call resume in a loop, whenever are new blocks
       gini: calculate gini coefficients
       stats: calculate the stats
       richest: calculate richest lists
       index_1: create indexes for movements
       index_2: create indexes for addresses
       populate: create the database movements with movements and closures.
       resume: update the database generated by populate with new incomming data.
       test-addresses: read every block and try to generate address for every single output.
       test-script: read the blockchain/scripts.log file and perform a custom test over each line.
       analyze-script: read and print an inform from blockchain/scripts.log.
    """)
  }
}
