import java.io.File
import actions._
import util._
import core._
import sys.process._
import collection.mutable.Map

/**
 * Created with IntelliJ IDEA.
 * User: yzark
 * Date: 11/19/1
 * Time: 12:36 PM
 * To change this template use File | Settings | File Templates.
 */
object Explorer extends App {
  args.toList match{
    case "start"::rest =>

      //Seq("rm", blockHashListFile).!
        // File blockStoreFile could be deleted and new generated here
      //Seq("touch", blockHashListFile).!
      // Ensure that bitcoind is running
      Seq("bitcoind","-daemon").run

      populate

      Seq("touch","/root/Bitcoin-Graph-Explorer/blockchain/lock").!
      iterateResume

    case "populate"::rest             =>

      
      populate

    case "resume"::rest =>

      iterateResume
      
    case "info"::rest =>

      getInfo

    case _=>

      println("""

        Available commands:

         start: populate, then resume 
         populate: create the database movements with movements and closures.
         resume: update the database generated by populate with new incoming data.

      """)
  }

  def getInfo = {
    val (count, amount) = sumUTXOs
    println("Sum of the utxos saved in the lmdb: "+ amount)
    println("Total utxos in the lmdb: " + count)
    val (countDB, amountDB) = countUTXOs
    println("Sum of the utxos in the sql db " +amountDB)
    println("Total utxos in the sql db " + countDB)
  }

  def sumUTXOs = {
    lazy val table = LmdbMap.open("utxos")
    lazy val outputMap: UTXOs = new UTXOs (table)
    // (txhash,index) -> (address,value,blockIn)
    val values = for ( (_,(_,value,_)) <- outputMap.view) yield value //makes it a lazy collection
    val tuple = values.grouped(100000).foldLeft((0,0L)){
      case ((count,sum),group) =>
        println(count + " elements read at " + java.util.Calendar.getInstance().getTime())
        val seq = group.toSeq
        (count+seq.size,sum+seq.sum)
    }

    table.close
    tuple
  }

  def populate = {
    initializeReaderTables
    initializeClosureTables
    initializeStatsTables

    insertStatistics
 
    PopulateBlockReader
  
    createIndexes
    new PopulateClosure(PopulateBlockReader.processedBlocks)
    createAddressIndexes    
    populateStats


  }

  def resume = {
    val read = new ResumeBlockReader
    val closure = new ResumeClosure(read.processedBlocks)
    println("DEBUG: making new stats")
    resumeStats(read.changedAddresses, closure.changedReps, closure.addedAds, closure.addedReps)
  }

  def iterateResume = {
    Seq("bitcoind","-daemon").run
    
    if (!peerGroup.isRunning) startBitcoinJ

    //val lch = lastCompletedHeight
    //val bc = blockCount

    // if there are more stats than blocks we could delete it
    //for (i <- (lch +1 until bc).reverse){
    //  println("rolling back block " + i + " at " + java.util.Calendar.getInstance().getTime())
    //  rollBack
    // }
    //if (lch < bc-1){
    //  println(lch + " - " + bc)
    //  populateStats
    //}
    while (new java.io.File("/root/Bitcoin-Graph-Explorer/blockchain/lock").exists)
    {
//      val from = blockCount
  //    val to = countLines(blockHashListFile)
      
    //  if (to > from)
    //  {
    //  println("Reading blocks from " + from + " until " + to)

      
      if (blockCount > chain.getBestChainHeight-5)
      {
        println("waiting for new blocks at " + java.util.Calendar.getInstance().getTime())
        chain.getHeightFuture(blockCount+5).get //wait until the chain is at least 6 blocks longer than we have read
      }

      val (count,amount) = sumUTXOs
      val (countDB, amountDB) = countUTXOs
      assert( count == countDB, "count differs " + count + "!="+countDB)
      assert(amount == amountDB, "amount differs " + amount + " != " + amountDB)
      // we need to implement here the total bitcoins formel.
      // assert(amount == 5000000000L*blockCount, "It should be " + (50*blockCount)+ " but we have " + (amount/100000000L - 50*blockCount) + " more bitcoins")


      resume
               

     // }
     // else
     // {
     //   println("waiting for new blocks")
     //   waitIfNewBlocks(to)
     // }
    }
    println("process stopped")
    //Seq("bitcoin-cli","stop").run
  }

  def resumeStats(changedAddresses: Map[Hash,Long], changedReps: Map[Hash,Set[Hash]], addedAds: Int, addedReps: Int) =
    if (changedAddresses.size < 30000 )
    {
      updateBalanceTables(changedAddresses, changedReps)
      insertRichestAddresses
      insertRichestClosures
      updateStatistics(changedReps,addedAds, addedReps)
    }
    else populateStats
        
 

  def populateStats = {
    createBalanceTables
    insertRichestAddresses
    insertRichestClosures
    insertStatistics
  }


}
